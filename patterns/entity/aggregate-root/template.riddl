// Aggregate Root Pattern
// Replace {AggregateName} with the parent entity name (e.g., Cart, Order)
// Replace {ChildName} with the child entity name (e.g., Item, Line)

entity {AggregateName} is {
  briefly "Aggregate root that manages {ChildName} children"

  // Aggregate identity
  type {AggregateName}Id is Id({AggregateName})

  // Child entity type
  type {ChildName} is {
    id: {ChildName}Id
    // TODO: Add child fields
  }
  type {ChildName}Id is Id({ChildName})

  // Commands operate on the aggregate
  command Add{ChildName} is {
    aggregateId: {AggregateName}Id,
    child: {ChildName}
  }
  command Remove{ChildName} is {
    aggregateId: {AggregateName}Id,
    childId: {ChildName}Id
  }

  // Events capture changes to the aggregate
  event {ChildName}Added is {
    aggregateId: {AggregateName}Id,
    child: {ChildName}
  }
  event {ChildName}Removed is {
    aggregateId: {AggregateName}Id,
    childId: {ChildName}Id
  }

  // State includes the collection of children
  state Active is {
    id: {AggregateName}Id,
    children: {ChildName}*
    // TODO: Add other aggregate state
  }

  handler {AggregateName}Handler is {
    on command Add{ChildName} {
      // TODO: Validate child doesn't exceed limits
      // TODO: Enforce aggregate invariants
      set field state.children to state.children + @Add{ChildName}.child
      send event {ChildName}Added to outlet Events
    }
    on command Remove{ChildName} {
      // TODO: Validate child exists
      set field state.children to state.children - @Remove{ChildName}.childId
      send event {ChildName}Removed to outlet Events
    }
  }
}